// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FLATBUFFERS_ROX_FB_H_
#define FLATBUFFERS_GENERATED_FLATBUFFERS_ROX_FB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace rox {
namespace fb {

struct Vector;
struct VectorBuilder;

struct DoubleValue;
struct DoubleValueBuilder;

struct IntValue;
struct IntValueBuilder;

struct StringValue;
struct StringValueBuilder;

struct Scalar;
struct ScalarBuilder;

struct Record;
struct RecordBuilder;

struct ScalarField;
struct ScalarFieldBuilder;

struct VectorField;
struct VectorFieldBuilder;

struct Schema;
struct SchemaBuilder;

struct IvfListEntry;
struct IvfListEntryBuilder;

struct IvfList;
struct IvfListBuilder;

struct IvfFlatIndex;
struct IvfFlatIndexBuilder;

enum ScalarValue : uint8_t {
  ScalarValue_NONE = 0,
  ScalarValue_DoubleValue = 1,
  ScalarValue_IntValue = 2,
  ScalarValue_StringValue = 3,
  ScalarValue_MIN = ScalarValue_NONE,
  ScalarValue_MAX = ScalarValue_StringValue
};

inline const ScalarValue (&EnumValuesScalarValue())[4] {
  static const ScalarValue values[] = {
    ScalarValue_NONE,
    ScalarValue_DoubleValue,
    ScalarValue_IntValue,
    ScalarValue_StringValue
  };
  return values;
}

inline const char * const *EnumNamesScalarValue() {
  static const char * const names[5] = {
    "NONE",
    "DoubleValue",
    "IntValue",
    "StringValue",
    nullptr
  };
  return names;
}

inline const char *EnumNameScalarValue(ScalarValue e) {
  if (::flatbuffers::IsOutRange(e, ScalarValue_NONE, ScalarValue_StringValue)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesScalarValue()[index];
}

template<typename T> struct ScalarValueTraits {
  static const ScalarValue enum_value = ScalarValue_NONE;
};

template<> struct ScalarValueTraits<rox::fb::DoubleValue> {
  static const ScalarValue enum_value = ScalarValue_DoubleValue;
};

template<> struct ScalarValueTraits<rox::fb::IntValue> {
  static const ScalarValue enum_value = ScalarValue_IntValue;
};

template<> struct ScalarValueTraits<rox::fb::StringValue> {
  static const ScalarValue enum_value = ScalarValue_StringValue;
};

bool VerifyScalarValue(::flatbuffers::Verifier &verifier, const void *obj, ScalarValue type);
bool VerifyScalarValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum ScalarFieldType : int8_t {
  ScalarFieldType_kDouble = 0,
  ScalarFieldType_kInt = 1,
  ScalarFieldType_kString = 2,
  ScalarFieldType_MIN = ScalarFieldType_kDouble,
  ScalarFieldType_MAX = ScalarFieldType_kString
};

inline const ScalarFieldType (&EnumValuesScalarFieldType())[3] {
  static const ScalarFieldType values[] = {
    ScalarFieldType_kDouble,
    ScalarFieldType_kInt,
    ScalarFieldType_kString
  };
  return values;
}

inline const char * const *EnumNamesScalarFieldType() {
  static const char * const names[4] = {
    "kDouble",
    "kInt",
    "kString",
    nullptr
  };
  return names;
}

inline const char *EnumNameScalarFieldType(ScalarFieldType e) {
  if (::flatbuffers::IsOutRange(e, ScalarFieldType_kDouble, ScalarFieldType_kString)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesScalarFieldType()[index];
}

struct Vector FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VectorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<float> *values() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
};

struct VectorBuilder {
  typedef Vector Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<float>> values) {
    fbb_.AddOffset(Vector::VT_VALUES, values);
  }
  explicit VectorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Vector>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Vector> CreateVector(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> values = 0) {
  VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Vector> CreateVectorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<float>(*values) : 0;
  return rox::fb::CreateVector(
      _fbb,
      values__);
}

struct DoubleValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DoubleValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct DoubleValueBuilder {
  typedef DoubleValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(DoubleValue::VT_VALUE, value, 0.0);
  }
  explicit DoubleValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DoubleValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DoubleValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DoubleValue> CreateDoubleValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  DoubleValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct IntValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct IntValueBuilder {
  typedef IntValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(IntValue::VT_VALUE, value, 0);
  }
  explicit IntValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntValue> CreateIntValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  IntValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct StringValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringValueBuilder {
  typedef StringValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(StringValue::VT_VALUE, value);
  }
  explicit StringValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringValue> CreateStringValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  StringValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StringValue> CreateStringValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return rox::fb::CreateStringValue(
      _fbb,
      value__);
}

struct Scalar FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScalarBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  rox::fb::ScalarValue value_type() const {
    return static_cast<rox::fb::ScalarValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const rox::fb::DoubleValue *value_as_DoubleValue() const {
    return value_type() == rox::fb::ScalarValue_DoubleValue ? static_cast<const rox::fb::DoubleValue *>(value()) : nullptr;
  }
  const rox::fb::IntValue *value_as_IntValue() const {
    return value_type() == rox::fb::ScalarValue_IntValue ? static_cast<const rox::fb::IntValue *>(value()) : nullptr;
  }
  const rox::fb::StringValue *value_as_StringValue() const {
    return value_type() == rox::fb::ScalarValue_StringValue ? static_cast<const rox::fb::StringValue *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyScalarValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const rox::fb::DoubleValue *Scalar::value_as<rox::fb::DoubleValue>() const {
  return value_as_DoubleValue();
}

template<> inline const rox::fb::IntValue *Scalar::value_as<rox::fb::IntValue>() const {
  return value_as_IntValue();
}

template<> inline const rox::fb::StringValue *Scalar::value_as<rox::fb::StringValue>() const {
  return value_as_StringValue();
}

struct ScalarBuilder {
  typedef Scalar Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value_type(rox::fb::ScalarValue value_type) {
    fbb_.AddElement<uint8_t>(Scalar::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Scalar::VT_VALUE, value);
  }
  explicit ScalarBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Scalar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Scalar>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Scalar> CreateScalar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rox::fb::ScalarValue value_type = rox::fb::ScalarValue_NONE,
    ::flatbuffers::Offset<void> value = 0) {
  ScalarBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct Record FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RecordBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_SCALARS = 6,
    VT_VECTORS = 8
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::Scalar>> *scalars() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::Scalar>> *>(VT_SCALARS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::Vector>> *vectors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::Vector>> *>(VT_VECTORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyOffset(verifier, VT_SCALARS) &&
           verifier.VerifyVector(scalars()) &&
           verifier.VerifyVectorOfTables(scalars()) &&
           VerifyOffset(verifier, VT_VECTORS) &&
           verifier.VerifyVector(vectors()) &&
           verifier.VerifyVectorOfTables(vectors()) &&
           verifier.EndTable();
  }
};

struct RecordBuilder {
  typedef Record Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Record::VT_ID, id, 0);
  }
  void add_scalars(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::Scalar>>> scalars) {
    fbb_.AddOffset(Record::VT_SCALARS, scalars);
  }
  void add_vectors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::Vector>>> vectors) {
    fbb_.AddOffset(Record::VT_VECTORS, vectors);
  }
  explicit RecordBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Record> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Record>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Record> CreateRecord(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::Scalar>>> scalars = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::Vector>>> vectors = 0) {
  RecordBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_vectors(vectors);
  builder_.add_scalars(scalars);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Record> CreateRecordDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const std::vector<::flatbuffers::Offset<rox::fb::Scalar>> *scalars = nullptr,
    const std::vector<::flatbuffers::Offset<rox::fb::Vector>> *vectors = nullptr) {
  auto scalars__ = scalars ? _fbb.CreateVector<::flatbuffers::Offset<rox::fb::Scalar>>(*scalars) : 0;
  auto vectors__ = vectors ? _fbb.CreateVector<::flatbuffers::Offset<rox::fb::Vector>>(*vectors) : 0;
  return rox::fb::CreateRecord(
      _fbb,
      id,
      scalars__,
      vectors__);
}

struct ScalarField FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScalarFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  rox::fb::ScalarFieldType type() const {
    return static_cast<rox::fb::ScalarFieldType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct ScalarFieldBuilder {
  typedef ScalarField Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ScalarField::VT_NAME, name);
  }
  void add_type(rox::fb::ScalarFieldType type) {
    fbb_.AddElement<int8_t>(ScalarField::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit ScalarFieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ScalarField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ScalarField>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ScalarField> CreateScalarField(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    rox::fb::ScalarFieldType type = rox::fb::ScalarFieldType_kDouble) {
  ScalarFieldBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ScalarField> CreateScalarFieldDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    rox::fb::ScalarFieldType type = rox::fb::ScalarFieldType_kDouble) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return rox::fb::CreateScalarField(
      _fbb,
      name__,
      type);
}

struct VectorField FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VectorFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DIM = 6,
    VT_NUM_CENTROIDS = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint32_t dim() const {
    return GetField<uint32_t>(VT_DIM, 0);
  }
  uint32_t num_centroids() const {
    return GetField<uint32_t>(VT_NUM_CENTROIDS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_DIM, 4) &&
           VerifyField<uint32_t>(verifier, VT_NUM_CENTROIDS, 4) &&
           verifier.EndTable();
  }
};

struct VectorFieldBuilder {
  typedef VectorField Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(VectorField::VT_NAME, name);
  }
  void add_dim(uint32_t dim) {
    fbb_.AddElement<uint32_t>(VectorField::VT_DIM, dim, 0);
  }
  void add_num_centroids(uint32_t num_centroids) {
    fbb_.AddElement<uint32_t>(VectorField::VT_NUM_CENTROIDS, num_centroids, 0);
  }
  explicit VectorFieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VectorField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VectorField>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VectorField> CreateVectorField(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint32_t dim = 0,
    uint32_t num_centroids = 0) {
  VectorFieldBuilder builder_(_fbb);
  builder_.add_num_centroids(num_centroids);
  builder_.add_dim(dim);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VectorField> CreateVectorFieldDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t dim = 0,
    uint32_t num_centroids = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return rox::fb::CreateVectorField(
      _fbb,
      name__,
      dim,
      num_centroids);
}

struct Schema FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SchemaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VECTOR_FIELDS = 4,
    VT_SCALAR_FIELDS = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::VectorField>> *vector_fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::VectorField>> *>(VT_VECTOR_FIELDS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::ScalarField>> *scalar_fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::ScalarField>> *>(VT_SCALAR_FIELDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VECTOR_FIELDS) &&
           verifier.VerifyVector(vector_fields()) &&
           verifier.VerifyVectorOfTables(vector_fields()) &&
           VerifyOffset(verifier, VT_SCALAR_FIELDS) &&
           verifier.VerifyVector(scalar_fields()) &&
           verifier.VerifyVectorOfTables(scalar_fields()) &&
           verifier.EndTable();
  }
};

struct SchemaBuilder {
  typedef Schema Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vector_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::VectorField>>> vector_fields) {
    fbb_.AddOffset(Schema::VT_VECTOR_FIELDS, vector_fields);
  }
  void add_scalar_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::ScalarField>>> scalar_fields) {
    fbb_.AddOffset(Schema::VT_SCALAR_FIELDS, scalar_fields);
  }
  explicit SchemaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Schema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Schema>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Schema> CreateSchema(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::VectorField>>> vector_fields = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::ScalarField>>> scalar_fields = 0) {
  SchemaBuilder builder_(_fbb);
  builder_.add_scalar_fields(scalar_fields);
  builder_.add_vector_fields(vector_fields);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Schema> CreateSchemaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<rox::fb::VectorField>> *vector_fields = nullptr,
    const std::vector<::flatbuffers::Offset<rox::fb::ScalarField>> *scalar_fields = nullptr) {
  auto vector_fields__ = vector_fields ? _fbb.CreateVector<::flatbuffers::Offset<rox::fb::VectorField>>(*vector_fields) : 0;
  auto scalar_fields__ = scalar_fields ? _fbb.CreateVector<::flatbuffers::Offset<rox::fb::ScalarField>>(*scalar_fields) : 0;
  return rox::fb::CreateSchema(
      _fbb,
      vector_fields__,
      scalar_fields__);
}

struct IvfListEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IvfListEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VECTOR = 6
  };
  uint64_t key() const {
    return GetField<uint64_t>(VT_KEY, 0);
  }
  const rox::fb::Vector *vector() const {
    return GetPointer<const rox::fb::Vector *>(VT_VECTOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_KEY, 8) &&
           VerifyOffset(verifier, VT_VECTOR) &&
           verifier.VerifyTable(vector()) &&
           verifier.EndTable();
  }
};

struct IvfListEntryBuilder {
  typedef IvfListEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(uint64_t key) {
    fbb_.AddElement<uint64_t>(IvfListEntry::VT_KEY, key, 0);
  }
  void add_vector(::flatbuffers::Offset<rox::fb::Vector> vector) {
    fbb_.AddOffset(IvfListEntry::VT_VECTOR, vector);
  }
  explicit IvfListEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IvfListEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IvfListEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IvfListEntry> CreateIvfListEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t key = 0,
    ::flatbuffers::Offset<rox::fb::Vector> vector = 0) {
  IvfListEntryBuilder builder_(_fbb);
  builder_.add_key(key);
  builder_.add_vector(vector);
  return builder_.Finish();
}

struct IvfList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IvfListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRIES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::IvfListEntry>> *entries() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::IvfListEntry>> *>(VT_ENTRIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTRIES) &&
           verifier.VerifyVector(entries()) &&
           verifier.VerifyVectorOfTables(entries()) &&
           verifier.EndTable();
  }
};

struct IvfListBuilder {
  typedef IvfList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_entries(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::IvfListEntry>>> entries) {
    fbb_.AddOffset(IvfList::VT_ENTRIES, entries);
  }
  explicit IvfListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IvfList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IvfList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IvfList> CreateIvfList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::IvfListEntry>>> entries = 0) {
  IvfListBuilder builder_(_fbb);
  builder_.add_entries(entries);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IvfList> CreateIvfListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<rox::fb::IvfListEntry>> *entries = nullptr) {
  auto entries__ = entries ? _fbb.CreateVector<::flatbuffers::Offset<rox::fb::IvfListEntry>>(*entries) : 0;
  return rox::fb::CreateIvfList(
      _fbb,
      entries__);
}

struct IvfFlatIndex FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IvfFlatIndexBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELD_NAME = 4,
    VT_DIM = 6,
    VT_NLIST = 8,
    VT_CENTROIDS = 10,
    VT_INVERTED_LISTS = 12
  };
  const ::flatbuffers::String *field_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIELD_NAME);
  }
  uint32_t dim() const {
    return GetField<uint32_t>(VT_DIM, 0);
  }
  uint32_t nlist() const {
    return GetField<uint32_t>(VT_NLIST, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::Vector>> *centroids() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::Vector>> *>(VT_CENTROIDS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::IvfList>> *inverted_lists() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::IvfList>> *>(VT_INVERTED_LISTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELD_NAME) &&
           verifier.VerifyString(field_name()) &&
           VerifyField<uint32_t>(verifier, VT_DIM, 4) &&
           VerifyField<uint32_t>(verifier, VT_NLIST, 4) &&
           VerifyOffset(verifier, VT_CENTROIDS) &&
           verifier.VerifyVector(centroids()) &&
           verifier.VerifyVectorOfTables(centroids()) &&
           VerifyOffset(verifier, VT_INVERTED_LISTS) &&
           verifier.VerifyVector(inverted_lists()) &&
           verifier.VerifyVectorOfTables(inverted_lists()) &&
           verifier.EndTable();
  }
};

struct IvfFlatIndexBuilder {
  typedef IvfFlatIndex Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_field_name(::flatbuffers::Offset<::flatbuffers::String> field_name) {
    fbb_.AddOffset(IvfFlatIndex::VT_FIELD_NAME, field_name);
  }
  void add_dim(uint32_t dim) {
    fbb_.AddElement<uint32_t>(IvfFlatIndex::VT_DIM, dim, 0);
  }
  void add_nlist(uint32_t nlist) {
    fbb_.AddElement<uint32_t>(IvfFlatIndex::VT_NLIST, nlist, 0);
  }
  void add_centroids(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::Vector>>> centroids) {
    fbb_.AddOffset(IvfFlatIndex::VT_CENTROIDS, centroids);
  }
  void add_inverted_lists(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::IvfList>>> inverted_lists) {
    fbb_.AddOffset(IvfFlatIndex::VT_INVERTED_LISTS, inverted_lists);
  }
  explicit IvfFlatIndexBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IvfFlatIndex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IvfFlatIndex>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IvfFlatIndex> CreateIvfFlatIndex(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> field_name = 0,
    uint32_t dim = 0,
    uint32_t nlist = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::Vector>>> centroids = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<rox::fb::IvfList>>> inverted_lists = 0) {
  IvfFlatIndexBuilder builder_(_fbb);
  builder_.add_inverted_lists(inverted_lists);
  builder_.add_centroids(centroids);
  builder_.add_nlist(nlist);
  builder_.add_dim(dim);
  builder_.add_field_name(field_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IvfFlatIndex> CreateIvfFlatIndexDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *field_name = nullptr,
    uint32_t dim = 0,
    uint32_t nlist = 0,
    const std::vector<::flatbuffers::Offset<rox::fb::Vector>> *centroids = nullptr,
    const std::vector<::flatbuffers::Offset<rox::fb::IvfList>> *inverted_lists = nullptr) {
  auto field_name__ = field_name ? _fbb.CreateString(field_name) : 0;
  auto centroids__ = centroids ? _fbb.CreateVector<::flatbuffers::Offset<rox::fb::Vector>>(*centroids) : 0;
  auto inverted_lists__ = inverted_lists ? _fbb.CreateVector<::flatbuffers::Offset<rox::fb::IvfList>>(*inverted_lists) : 0;
  return rox::fb::CreateIvfFlatIndex(
      _fbb,
      field_name__,
      dim,
      nlist,
      centroids__,
      inverted_lists__);
}

inline bool VerifyScalarValue(::flatbuffers::Verifier &verifier, const void *obj, ScalarValue type) {
  switch (type) {
    case ScalarValue_NONE: {
      return true;
    }
    case ScalarValue_DoubleValue: {
      auto ptr = reinterpret_cast<const rox::fb::DoubleValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue_IntValue: {
      auto ptr = reinterpret_cast<const rox::fb::IntValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue_StringValue: {
      auto ptr = reinterpret_cast<const rox::fb::StringValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyScalarValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyScalarValue(
        verifier,  values->Get(i), types->GetEnum<ScalarValue>(i))) {
      return false;
    }
  }
  return true;
}

inline const rox::fb::Schema *GetSchema(const void *buf) {
  return ::flatbuffers::GetRoot<rox::fb::Schema>(buf);
}

inline const rox::fb::Schema *GetSizePrefixedSchema(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<rox::fb::Schema>(buf);
}

inline bool VerifySchemaBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<rox::fb::Schema>(nullptr);
}

inline bool VerifySizePrefixedSchemaBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<rox::fb::Schema>(nullptr);
}

inline void FinishSchemaBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<rox::fb::Schema> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSchemaBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<rox::fb::Schema> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fb
}  // namespace rox

#endif  // FLATBUFFERS_GENERATED_FLATBUFFERS_ROX_FB_H_
